# Security on the TLS/SSL Handshake Protocol and Application Data Protocol
---------------------------------------------------------------------------------------------------------------------

Code explanation:
1. For the project implementation, the TCP and most of the SSL code are already provided. Hence, our implementation is focused on completing two of the following functions: “connect()” in SslClient and “accept()” in SslServer to send and receive handshake records between client and server. In this project, we will be using DHE key exchange approach and RSA encryption for implementing key exchange in TLS.
2. As the first step of the TLS handshake, the SSL client sends a ClientHello record containing the “client random” and the key exchange protocol /algorithm (RSA or DHE) which is being used. The SSL server responds with a Server Hello record that contains a “server random” and that record also mentions the key exchange protocol that is going to be used. The entity authentication part is already considered to be done. so, we will not be implementing that in our code.
3. Hence, for RSA encryption in key exchange, the server will be directly sending the server’s public key to the client. The client then generates the premaster key and sends a ClientKeyExchange record containing the encrypted premaster key which is encrypted using the server’s public key. The server then decrypts the premaster key using its private key. Further, both the client and the server use the premaster key, the “client random”, and “server random” received in the handshake to derive the master secret. From the master secret, we derive the session key using the KDF (key derivation function). The main goal of our project here is to implement key generation. So, after generating the key, we directly set up the SSL/TLS connection to encrypt and decrypt the App data.
4. For DHE key exchange protocol, the client and server generate their own private and public key using the P, Q, and G value (DHE parameters) which is generated randomly every session. The server then directly sends the server’s public key to the client in ServerKeyExchange record and the client directly sends its public key to the server in ClientKeyExchange record. Both the client and the server then generate the premaster key using the server’s and client’s public key, which is then used to derive the master secret. From the master secret, we derive the session key using the KDF (key derivation function. Now that the keys are generated, we directly set up the SSL/TLS connection to encrypt and decrypt the App data.
